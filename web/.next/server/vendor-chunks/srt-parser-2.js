"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/srt-parser-2";
exports.ids = ["vendor-chunks/srt-parser-2"];
exports.modules = {

/***/ "(ssr)/../node_modules/srt-parser-2/dist/index.js":
/*!**************************************************!*\
  !*** ../node_modules/srt-parser-2/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Parser {\n    seperator = \",\";\n    timestampToSeconds(srtTimestamp) {\n        const [rest, millisecondsString] = srtTimestamp.split(\",\");\n        const milliseconds = parseInt(millisecondsString);\n        const [hours, minutes, seconds] = rest.split(\":\").map((x) => parseInt(x));\n        const result = milliseconds * 0.001 + seconds + 60 * minutes + 3600 * hours;\n        // fix odd JS roundings, e.g. timestamp '00:01:20,460' result is 80.46000000000001\n        return Math.round(result * 1000) / 1000;\n    }\n    ;\n    correctFormat(time) {\n        // Fix the format if the format is wrong\n        // 00:00:28.9670 Become 00:00:28,967\n        // 00:00:28.967  Become 00:00:28,967\n        // 00:00:28.96   Become 00:00:28,960\n        // 00:00:28.9    Become 00:00:28,900\n        // 00:00:28,96   Become 00:00:28,960\n        // 00:00:28,9    Become 00:00:28,900\n        // 00:00:28,0    Become 00:00:28,000\n        // 00:00:28,01   Become 00:00:28,010\n        // 0:00:10,500   Become 00:00:10,500\n        let str = time.replace(\".\", \",\");\n        var hour = null;\n        var minute = null;\n        var second = null;\n        var millisecond = null;\n        // Handle millisecond\n        var [front, ms] = str.split(\",\");\n        millisecond = this.fixed_str_digit(3, ms);\n        // Handle hour\n        var [a_hour, a_minute, a_second] = front.split(\":\");\n        hour = this.fixed_str_digit(2, a_hour, false);\n        minute = this.fixed_str_digit(2, a_minute, false);\n        second = this.fixed_str_digit(2, a_second, false);\n        return `${hour}:${minute}:${second},${millisecond}`;\n    }\n    /*\n    // make sure string is 'how_many_digit' long\n    // if str is shorter than how_many_digit, pad with 0\n    // if str is longer than how_many_digit, slice from the beginning\n    // Example:\n  \n    Input: fixed_str_digit(3, '100')\n    Output: 100\n    Explain: unchanged, because \"100\" is 3 digit\n  \n    Input: fixed_str_digit(3, '50')\n    Output: 500\n    Explain: pad end with 0\n  \n    Input: fixed_str_digit(3, '50', false)\n    Output: 050\n    Explain: pad start with 0\n  \n    Input: fixed_str_digit(3, '7771')\n    Output: 777\n    Explain: slice from beginning\n    */\n    fixed_str_digit(how_many_digit, str, padEnd = true) {\n        if (str.length == how_many_digit) {\n            return str;\n        }\n        if (str.length > how_many_digit) {\n            return str.slice(0, how_many_digit);\n        }\n        if (str.length < how_many_digit) {\n            if (padEnd) {\n                return str.padEnd(how_many_digit, \"0\");\n            }\n            else {\n                return str.padStart(how_many_digit, \"0\");\n            }\n        }\n    }\n    tryComma(data) {\n        data = data.replace(/\\r/g, \"\");\n        var regex = /(\\d+)\\n(\\d{1,2}:\\d{2}:\\d{2},\\d{1,3}) --> (\\d{1,2}:\\d{2}:\\d{2},\\d{1,3})/g;\n        let data_array = data.split(regex);\n        data_array.shift(); // remove first '' in array\n        return data_array;\n    }\n    tryDot(data) {\n        data = data.replace(/\\r/g, \"\");\n        var regex = /(\\d+)\\n(\\d{1,2}:\\d{2}:\\d{2}\\.\\d{1,3}) --> (\\d{1,2}:\\d{2}:\\d{2}\\.\\d{1,3})/g;\n        let data_array = data.split(regex);\n        data_array.shift(); // remove first '' in array\n        this.seperator = \".\";\n        return data_array;\n    }\n    fromSrt(data) {\n        var originalData = data;\n        var data_array = this.tryComma(originalData);\n        if (data_array.length == 0) {\n            data_array = this.tryDot(originalData);\n        }\n        var items = [];\n        for (var i = 0; i < data_array.length; i += 4) {\n            const startTime = this.correctFormat(data_array[i + 1].trim());\n            const endTime = this.correctFormat(data_array[i + 2].trim());\n            var new_line = {\n                id: data_array[i].trim(),\n                startTime,\n                startSeconds: this.timestampToSeconds(startTime),\n                endTime,\n                endSeconds: this.timestampToSeconds(endTime),\n                text: data_array[i + 3].trim(),\n            };\n            items.push(new_line);\n        }\n        return items;\n    }\n    toSrt(data) {\n        var res = \"\";\n        const end_of_line = \"\\r\\n\";\n        for (var i = 0; i < data.length; i++) {\n            var s = data[i];\n            res += s.id + end_of_line;\n            res += s.startTime + \" --> \" + s.endTime + end_of_line;\n            res += s.text.replace(\"\\n\", end_of_line) + end_of_line + end_of_line;\n        }\n        return res;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parser);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NydC1wYXJzZXItMi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssR0FBRyxPQUFPLEdBQUcsT0FBTyxHQUFHLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxJQUFJLFVBQVUsSUFBSSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksSUFBSTtBQUMxRjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxJQUFJLFVBQVUsSUFBSSxJQUFJLEVBQUUsSUFBSSxFQUFFLEtBQUssSUFBSTtBQUM1RjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE1BQU0sRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvdmFsZW50aW5lL3Byb2plY3RzL0F1ZGlvTGVhcm4tRnJvbnQvbm9kZV9tb2R1bGVzL3NydC1wYXJzZXItMi9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFBhcnNlciB7XG4gICAgc2VwZXJhdG9yID0gXCIsXCI7XG4gICAgdGltZXN0YW1wVG9TZWNvbmRzKHNydFRpbWVzdGFtcCkge1xuICAgICAgICBjb25zdCBbcmVzdCwgbWlsbGlzZWNvbmRzU3RyaW5nXSA9IHNydFRpbWVzdGFtcC5zcGxpdChcIixcIik7XG4gICAgICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IHBhcnNlSW50KG1pbGxpc2Vjb25kc1N0cmluZyk7XG4gICAgICAgIGNvbnN0IFtob3VycywgbWludXRlcywgc2Vjb25kc10gPSByZXN0LnNwbGl0KFwiOlwiKS5tYXAoKHgpID0+IHBhcnNlSW50KHgpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWlsbGlzZWNvbmRzICogMC4wMDEgKyBzZWNvbmRzICsgNjAgKiBtaW51dGVzICsgMzYwMCAqIGhvdXJzO1xuICAgICAgICAvLyBmaXggb2RkIEpTIHJvdW5kaW5ncywgZS5nLiB0aW1lc3RhbXAgJzAwOjAxOjIwLDQ2MCcgcmVzdWx0IGlzIDgwLjQ2MDAwMDAwMDAwMDAxXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHJlc3VsdCAqIDEwMDApIC8gMTAwMDtcbiAgICB9XG4gICAgO1xuICAgIGNvcnJlY3RGb3JtYXQodGltZSkge1xuICAgICAgICAvLyBGaXggdGhlIGZvcm1hdCBpZiB0aGUgZm9ybWF0IGlzIHdyb25nXG4gICAgICAgIC8vIDAwOjAwOjI4Ljk2NzAgQmVjb21lIDAwOjAwOjI4LDk2N1xuICAgICAgICAvLyAwMDowMDoyOC45NjcgIEJlY29tZSAwMDowMDoyOCw5NjdcbiAgICAgICAgLy8gMDA6MDA6MjguOTYgICBCZWNvbWUgMDA6MDA6MjgsOTYwXG4gICAgICAgIC8vIDAwOjAwOjI4LjkgICAgQmVjb21lIDAwOjAwOjI4LDkwMFxuICAgICAgICAvLyAwMDowMDoyOCw5NiAgIEJlY29tZSAwMDowMDoyOCw5NjBcbiAgICAgICAgLy8gMDA6MDA6MjgsOSAgICBCZWNvbWUgMDA6MDA6MjgsOTAwXG4gICAgICAgIC8vIDAwOjAwOjI4LDAgICAgQmVjb21lIDAwOjAwOjI4LDAwMFxuICAgICAgICAvLyAwMDowMDoyOCwwMSAgIEJlY29tZSAwMDowMDoyOCwwMTBcbiAgICAgICAgLy8gMDowMDoxMCw1MDAgICBCZWNvbWUgMDA6MDA6MTAsNTAwXG4gICAgICAgIGxldCBzdHIgPSB0aW1lLnJlcGxhY2UoXCIuXCIsIFwiLFwiKTtcbiAgICAgICAgdmFyIGhvdXIgPSBudWxsO1xuICAgICAgICB2YXIgbWludXRlID0gbnVsbDtcbiAgICAgICAgdmFyIHNlY29uZCA9IG51bGw7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZCA9IG51bGw7XG4gICAgICAgIC8vIEhhbmRsZSBtaWxsaXNlY29uZFxuICAgICAgICB2YXIgW2Zyb250LCBtc10gPSBzdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgICBtaWxsaXNlY29uZCA9IHRoaXMuZml4ZWRfc3RyX2RpZ2l0KDMsIG1zKTtcbiAgICAgICAgLy8gSGFuZGxlIGhvdXJcbiAgICAgICAgdmFyIFthX2hvdXIsIGFfbWludXRlLCBhX3NlY29uZF0gPSBmcm9udC5zcGxpdChcIjpcIik7XG4gICAgICAgIGhvdXIgPSB0aGlzLmZpeGVkX3N0cl9kaWdpdCgyLCBhX2hvdXIsIGZhbHNlKTtcbiAgICAgICAgbWludXRlID0gdGhpcy5maXhlZF9zdHJfZGlnaXQoMiwgYV9taW51dGUsIGZhbHNlKTtcbiAgICAgICAgc2Vjb25kID0gdGhpcy5maXhlZF9zdHJfZGlnaXQoMiwgYV9zZWNvbmQsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGAke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH0sJHttaWxsaXNlY29uZH1gO1xuICAgIH1cbiAgICAvKlxuICAgIC8vIG1ha2Ugc3VyZSBzdHJpbmcgaXMgJ2hvd19tYW55X2RpZ2l0JyBsb25nXG4gICAgLy8gaWYgc3RyIGlzIHNob3J0ZXIgdGhhbiBob3dfbWFueV9kaWdpdCwgcGFkIHdpdGggMFxuICAgIC8vIGlmIHN0ciBpcyBsb25nZXIgdGhhbiBob3dfbWFueV9kaWdpdCwgc2xpY2UgZnJvbSB0aGUgYmVnaW5uaW5nXG4gICAgLy8gRXhhbXBsZTpcbiAgXG4gICAgSW5wdXQ6IGZpeGVkX3N0cl9kaWdpdCgzLCAnMTAwJylcbiAgICBPdXRwdXQ6IDEwMFxuICAgIEV4cGxhaW46IHVuY2hhbmdlZCwgYmVjYXVzZSBcIjEwMFwiIGlzIDMgZGlnaXRcbiAgXG4gICAgSW5wdXQ6IGZpeGVkX3N0cl9kaWdpdCgzLCAnNTAnKVxuICAgIE91dHB1dDogNTAwXG4gICAgRXhwbGFpbjogcGFkIGVuZCB3aXRoIDBcbiAgXG4gICAgSW5wdXQ6IGZpeGVkX3N0cl9kaWdpdCgzLCAnNTAnLCBmYWxzZSlcbiAgICBPdXRwdXQ6IDA1MFxuICAgIEV4cGxhaW46IHBhZCBzdGFydCB3aXRoIDBcbiAgXG4gICAgSW5wdXQ6IGZpeGVkX3N0cl9kaWdpdCgzLCAnNzc3MScpXG4gICAgT3V0cHV0OiA3NzdcbiAgICBFeHBsYWluOiBzbGljZSBmcm9tIGJlZ2lubmluZ1xuICAgICovXG4gICAgZml4ZWRfc3RyX2RpZ2l0KGhvd19tYW55X2RpZ2l0LCBzdHIsIHBhZEVuZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT0gaG93X21hbnlfZGlnaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiBob3dfbWFueV9kaWdpdCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zbGljZSgwLCBob3dfbWFueV9kaWdpdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCBob3dfbWFueV9kaWdpdCkge1xuICAgICAgICAgICAgaWYgKHBhZEVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIucGFkRW5kKGhvd19tYW55X2RpZ2l0LCBcIjBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnBhZFN0YXJ0KGhvd19tYW55X2RpZ2l0LCBcIjBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5Q29tbWEoZGF0YSkge1xuICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9cXHIvZywgXCJcIik7XG4gICAgICAgIHZhciByZWdleCA9IC8oXFxkKylcXG4oXFxkezEsMn06XFxkezJ9OlxcZHsyfSxcXGR7MSwzfSkgLS0+IChcXGR7MSwyfTpcXGR7Mn06XFxkezJ9LFxcZHsxLDN9KS9nO1xuICAgICAgICBsZXQgZGF0YV9hcnJheSA9IGRhdGEuc3BsaXQocmVnZXgpO1xuICAgICAgICBkYXRhX2FycmF5LnNoaWZ0KCk7IC8vIHJlbW92ZSBmaXJzdCAnJyBpbiBhcnJheVxuICAgICAgICByZXR1cm4gZGF0YV9hcnJheTtcbiAgICB9XG4gICAgdHJ5RG90KGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvXFxyL2csIFwiXCIpO1xuICAgICAgICB2YXIgcmVnZXggPSAvKFxcZCspXFxuKFxcZHsxLDJ9OlxcZHsyfTpcXGR7Mn1cXC5cXGR7MSwzfSkgLS0+IChcXGR7MSwyfTpcXGR7Mn06XFxkezJ9XFwuXFxkezEsM30pL2c7XG4gICAgICAgIGxldCBkYXRhX2FycmF5ID0gZGF0YS5zcGxpdChyZWdleCk7XG4gICAgICAgIGRhdGFfYXJyYXkuc2hpZnQoKTsgLy8gcmVtb3ZlIGZpcnN0ICcnIGluIGFycmF5XG4gICAgICAgIHRoaXMuc2VwZXJhdG9yID0gXCIuXCI7XG4gICAgICAgIHJldHVybiBkYXRhX2FycmF5O1xuICAgIH1cbiAgICBmcm9tU3J0KGRhdGEpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsRGF0YSA9IGRhdGE7XG4gICAgICAgIHZhciBkYXRhX2FycmF5ID0gdGhpcy50cnlDb21tYShvcmlnaW5hbERhdGEpO1xuICAgICAgICBpZiAoZGF0YV9hcnJheS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgZGF0YV9hcnJheSA9IHRoaXMudHJ5RG90KG9yaWdpbmFsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YV9hcnJheS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gdGhpcy5jb3JyZWN0Rm9ybWF0KGRhdGFfYXJyYXlbaSArIDFdLnRyaW0oKSk7XG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gdGhpcy5jb3JyZWN0Rm9ybWF0KGRhdGFfYXJyYXlbaSArIDJdLnRyaW0oKSk7XG4gICAgICAgICAgICB2YXIgbmV3X2xpbmUgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGRhdGFfYXJyYXlbaV0udHJpbSgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBzdGFydFNlY29uZHM6IHRoaXMudGltZXN0YW1wVG9TZWNvbmRzKHN0YXJ0VGltZSksXG4gICAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgICAgICBlbmRTZWNvbmRzOiB0aGlzLnRpbWVzdGFtcFRvU2Vjb25kcyhlbmRUaW1lKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBkYXRhX2FycmF5W2kgKyAzXS50cmltKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaXRlbXMucHVzaChuZXdfbGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICB0b1NydChkYXRhKSB7XG4gICAgICAgIHZhciByZXMgPSBcIlwiO1xuICAgICAgICBjb25zdCBlbmRfb2ZfbGluZSA9IFwiXFxyXFxuXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHMgPSBkYXRhW2ldO1xuICAgICAgICAgICAgcmVzICs9IHMuaWQgKyBlbmRfb2ZfbGluZTtcbiAgICAgICAgICAgIHJlcyArPSBzLnN0YXJ0VGltZSArIFwiIC0tPiBcIiArIHMuZW5kVGltZSArIGVuZF9vZl9saW5lO1xuICAgICAgICAgICAgcmVzICs9IHMudGV4dC5yZXBsYWNlKFwiXFxuXCIsIGVuZF9vZl9saW5lKSArIGVuZF9vZl9saW5lICsgZW5kX29mX2xpbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/srt-parser-2/dist/index.js\n");

/***/ })

};
;